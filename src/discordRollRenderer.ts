import { RollBase, DiceExpressionRoll, GroupRoll, DiceRollResult, ExpressionRoll, DieRoll, FateDieRoll, MathFunctionRoll, RollQueryRoll } from "./rollTypes";

/** An example renderer class that renders a roll to a string in a markdown format, compatible with Discord */
export class DiscordRollRenderer {
	/**
	 * Renders a dice roll in a format compatible with Discord
	 * @param roll a {@link RollBase} object that has been generated by the {@link DiceRoller}
	 * @returns a string representing the roll that can be used on Discord
	 */
	public render(roll: RollBase) {
		return this.doRender(roll, true);
	}

	private doRender(roll: RollBase, root = false) {
		if (!roll) {
			throw new Error("Unable to render: roll object is null/undefined");
		}
		
		let render = "";

		const type = roll.type;

		switch (type) {
			case "diceexpressionroll":
				render = this.renderGroupExpr(roll as DiceExpressionRoll);
				break;
			case "grouproll":
				render = this.renderGroup(roll as GroupRoll);
				break;
			case "die":
				render = this.renderDie(roll as DiceRollResult);
				break;
			case "expressionroll":
				render = this.renderExpression(roll as ExpressionRoll);
				break;
			case "mathfunction":
				render = this.renderFunction(roll as MathFunctionRoll);
				break;
			case "rollquery":
				return (roll as RollQueryRoll).value.toString();
			case "roll":
				return this.renderRoll(roll as DieRoll);
			case "fateroll":
				return this.renderFateRoll(roll as FateDieRoll);
			case "number":
				const label = roll.label
					? ` (${roll.label})`
					: "";
				return `${roll.value}${label}`;
			case "fate":
				return `F`;
			default:
				throw new Error(`Unable to render type: ${type}`);
		}

		if (!roll.valid) {
			render = "~~" + render.replace(/~~/g, "") + "~~";
		}

		if (root) {
			return this.stripBrackets(render);
		}

		return roll.label ? `(${roll.label}: ${render})` : render;
	}

	private renderGroup(group: GroupRoll) {
		const replies: string[] = [];

		for (const die of group.dice) {
			replies.push(this.doRender(die));
		}

		if (replies.length > 1) {
			return `{ ${replies.join(" + ")} } = ${group.value}`;
		}

		let reply = this.stripBrackets(replies[0]);
		
		// Avoid redundant "= value" when the inner die already shows the same value
		// This happens with success-counting rolls in groups like {4d10cs>7}
		// which would otherwise show "{ 6, 11, 9, 5 = 2 } = 2"
		// Strip the inner "= X" suffix when values match
		if (group.dice.length === 1 && group.dice[0].value === group.value) {
			// Remove the trailing " = X" or " = X Matches" from the inner render
			reply = reply.replace(/ = \d+( Match(es)?)?$/, '');
			return `{ ${reply} } = ${group.value}`;
		}
		
		return `{ ${reply} } = ${group.value}`;
	}

	private renderGroupExpr(group: DiceExpressionRoll) {
		const replies: string[] = [];

		for (const die of group.dice) {
			replies.push(this.doRender(die));
		}

		return replies.length > 1 ? `(${replies.join(" + ")} = ${group.value})` : replies[0];
	}

	private renderDie(die: DiceRollResult) {
		// Group exploding dice chains together
		// When a die explodes, it and subsequent explosions should be grouped like {10, 8, 3}
		const renderedRolls: string[] = [];
		let explosionChain: string[] = [];
		
		for (let i = 0; i < die.rolls.length; i++) {
			const roll = die.rolls[i];
			const rendered = this.doRender(roll);
			
			if (roll.explode) {
				// This roll exploded, start or continue a chain
				explosionChain.push(rendered);
			} else if (explosionChain.length > 0) {
				// This roll is the end of an explosion chain (the final non-exploding roll)
				explosionChain.push(rendered);
				renderedRolls.push(`{${explosionChain.join(", ")}}`);
				explosionChain = [];
			} else {
				// Normal roll, no explosion
				renderedRolls.push(rendered);
			}
		}
		
		// Handle any remaining explosion chain (shouldn't happen normally, but just in case)
		if (explosionChain.length > 0) {
			renderedRolls.push(`{${explosionChain.join(", ")}}`);
		}

		let reply = `${renderedRolls.join(", ")}`;

		if (!["number", "fate"].includes(die.die.type) || die.count.type !== "number") {
			reply += `[*Rolling: ${this.doRender(die.count)}d${this.doRender(die.die)}*]`;
		}

		const matches = die.matched
			? ` Match${die.value === 1 ? "" : "es"}`
			: "";
		reply += ` = ${die.value}${matches}`;
		return `(${reply})`;
	}

	private renderExpression(expr: ExpressionRoll) {
		if (expr.dice.length > 1) {
			const expressions: string[] = [];

			for (let i = 0; i < expr.dice.length - 1; i++) {
				expressions.push(this.doRender(expr.dice[i]));
				expressions.push(expr.ops[i]);
			}

			expressions.push(this.doRender(expr.dice.slice(-1)[0]));
			expressions.push("=");
			expressions.push(expr.value + "");

			return `(${expressions.join(" ")})`;
		} else if (expr.dice[0].type === "number") {
			return expr.value + "";
		} else {
			return this.doRender(expr.dice[0]);
		}
	}

	private renderFunction(roll: MathFunctionRoll) {
		const render = this.doRender(roll.expr);
		return `(${roll.op}${this.addBrackets(render)} = ${roll.value})`;
	}

	private addBrackets(render: string) {
		if (!render.startsWith("(")) {
			render = `(${render}`;
		}
		if (!render.endsWith(")")) {
			render = `${render})`;
		}
		return render;
	}

	private stripBrackets(render: string) {
		if (render.startsWith("(")) {
			render = render.substring(1);
		}
		if (render.endsWith(")")) {
			render = render.substring(0, render.length - 1);
		}
		return render;
	}

	private renderRoll(roll: DieRoll) {
		let rollDisplay = `${roll.roll}`;
		if (!roll.valid) {
			rollDisplay = `~~${roll.roll}~~`;
		} else if (roll.success && roll.value >= 1) { // Changed === 1 to >= 1
			rollDisplay = `**${roll.roll}**`;
		} else if (roll.success && roll.value === -1) {
			rollDisplay = `*${roll.roll}*`;
		} else if (!roll.success && roll.critical === "success") {
			rollDisplay = `**${roll.roll}**`;
		} else if (!roll.success && roll.critical === "failure") {
			rollDisplay = `*${roll.roll}*`;
		}

		if (roll.matched) {
			rollDisplay = `__${rollDisplay}__`;
		}

		return rollDisplay;
	}

	private renderFateRoll(roll: FateDieRoll) {
		const rollValue: string = roll.roll === 0
			? "0"
			: roll.roll > 0
				? "+"
				: "-";

		let rollDisplay = `${roll.roll}`;
		if (!roll.valid) {
			rollDisplay = `~~${rollValue}~~`;
		} else if (roll.success && roll.value === 1) {
			rollDisplay = `**${rollValue}**`;
		} else if (roll.success && roll.value === -1) {
			rollDisplay = `*${rollValue}*`;
		}

		if (roll.matched) {
			rollDisplay = `__${rollDisplay}__`;
		}

		return rollDisplay;
	}
}